#!/bin/sh
#; -*- mode: Makefile;-*-
#the next line restarts using\
exec make --trace --warn-undefined-variables -Rf "$0"  ${1+"$@"} 
# --trace
# =========================================================
# Copyright 2015
#
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
# =========================================================
###############################################################
# disable deletion of temporary files
.SECONDARY: 
.ONESHELL:

SHELL=bash
##################
# Setup some paths
# path to script


# Requires make 4.1 or above
VERSION_OK=$(shell if [ `make --version|head -n 1 | cut -f3 -d\ ` \< 4.1 ]; then echo 0; else echo 1; fi )
ifeq ($(VERSION_OK),0)
 $(error make version needs to be 4.1 or above)
endif

script_path!=dirname "`which eqtl_pipeline`"
################################################################################
# Auxiliary functions
################################################################################

# Information messages
define p_info=
$(info $(shell date "+%H:%M:%S %d/%m/%Y * ") $(1))
endef

# Error messages
define p_error=
$(info $(shell date "+%H:%M:%S %d/%m/%Y") * ERROR: $(1)) && $(error Fatal error)
endef

# complain if a file does not exist and exit
file_exists=$(if  $(realpath $(1)),,$(call p_error,$(1) not found))

#  check if a variable  $(1) is defined - return the variable name if it is defined or empty otherwise
is_defined=$(if $(subst undefined,,$(origin $(1))),$(1),)


################################################################################
# Variables
################################################################################

#Version and license info
pname=eqtlXXXXX
version=0.0.1
contact="Add contact"
license=This pipeline is distributed  under the terms of the GNU General Public License 3


################################################################################
# Default values
################################################################################
maf=0.02
define get_mac=
$(shell bash -c "echo \($(words $(vcfs)) \* $(maf) \* 2 +1\)/1 | bc")
endef


################################################################################
# go

$(info *****************************************************)
$(info * $(pname) $(version))
$(info * $(contact))
$(info * $(license))
$(info *)
$(info * Initializing...)


###############################################
# Load configuration (mandatory)
# use a configuration file?
ifdef conf
 $(call file_exists,$(conf))
 $(info * Trying to load configuration file $(conf)...)
 include $(conf)
 $(info * Configuration loaded.)
else
 $(call p_error,Configuration file missing)
endif

###############################################################
# Check and validate the parameters values

$(info * )
$(info * Required Parameters:)

#***********************
# Name of the experiment
ifndef name
 $(call p_error, missing argument name!)
else
 $(info *	name=$(name))
endif


# expr_matrix (TSV File)
ifndef expr_matrix
 $(call p_error, missing argument expr_matrix!)
else
 $(info *	expr_matrix=$(expr_matrix))
endif
$(call file_exists,$(expr_matrix))

# two columns
# 1st column: DNA
# 2st column: RNA
ifndef dna_rna_mapfile
 $(call p_error, missing argument dna_rna_mapfile)
else
 $(info *	dna_rna_mapfile=$(dna_rna_mapfile))
endif
$(call file_exists,$(dna_rna_mapfile))



#************************
# ?
ifndef vcf_toplevel_dir
$(call p_error,vcf_toplevel_dir not defined)
endif
$(info *	vcf_toplevel_dir=$(vcf_toplevel_dir))

ifndef vcfs
 $(call p_error,missing argument vcfs)
endif
ifeq (1,$(words $(vcfs)))
$(call p_error,insufficient number of VCF files (please provide two or more files))
endif
$(info *	vcfs=$(vcfs))
#$(call file_exists,$(vcfs))
$(foreach l,$(vcfs),$(call file_exists,$(vcf_toplevel_dir)/$(l)))

#
ifndef cov_matrix
cov_matrix=none
$(call p_error,cov_matrix not defined)
endif
$(call file_exists,$(cov_matrix))
$(info *	cov_matrix=$(cov_matrix))
# eqtl_pipeline vcfs=`ls mydir/*.vcf.gz`


#********* 
# GTF file?
ifndef gtf_file
 $(error gtf_file not defined)
endif
$(info *       gtf_file  = $(gtf_file))
$(call file_exists,$(gtf_file))


#*************
# sample2class
# file containing the mapping between samples and a class/label
ifndef sample2class_file
 $(error sample2class_file not defined)
endif
$(info *       sample2class_file  = $(sample2class_file))
$(call file_exists,$(sample2class_file))


# default list of chromosomes
chromosomes?=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y MT


# LIMIX binary folder
LIMIX_BINARY=$(EPIPELINE_DIR)/anaconda/bin

#####################
# Other Optional parameters
#####################
$(info * )
$(info * Optional Parameters:)


#
def_vars=minGQ minRD  min_expr min_perc_samples expr_transform hidden_k max_missing mac peer_iterations snr_threshold max_missing vcf_filter_cmd chromosomes n_folds fdr_threshold subfolder_name cis_window limix_use_peer_covariates

subfolder_name?=
peer_iterations?=100
fdr_threshold?=0.05
minGQ?=50
minRD?=20
limix_use_peer_covariates?=n
cis_window?=1000000
# signal-to-noise ration threshold
snr_threshold?=75
# vcf_filter="TP > 0.95 ....."

vcf_filter_cmd=annai_filter_vcf.sh

n_folds?=1000
min_expr?=1
min_perc_samples?=0.5
#possible values: gaussian log none
expr_transform?=none
hidden_k?=10
max_missing?=0.8
eqtl_method?=limix

mac?=20

$(foreach v,$(def_vars),$(info * 	$(v)=$($(v))))


##############################
# expression correction method
SUPPORTED_CORR_METHODS=peer panama
ifndef corr_method
corr_method=none
endif

#corr_method expr_corr_method?
ifeq (,$(filter $(corr_method),$(SUPPORTED_CORR_METHODS) none))
$(error corr_method value $(corr_method) not supported)
endif

#ifeq ($(corr_method),peer) 
$(info *	corr_method=$(corr_method))
#endif


###############################
#
SUPPORTED_EQTL_METHODS=limix matrix_eqtl

#corr_method expr_corr_method?
ifeq (,$(filter $(eqtl_method),$(SUPPORTED_EQTL_METHODS)))
$(error eqtl_method value $(eqtl_method) not supported)
endif

#ifeq ($(corr_method),peer) 
$(info *	eqtl_method=$(eqtl_method))
#endif



#
TARGETS0=
TARGETS1=
TARGETS2=
TARGETS3=
TARGETS4=
TARGETS5=
TARGETS6=
TARGETS7=
TARGETS8=
TARGETS9=

#
# ${name}
#   |+-------------dna_[dna_filter_options_md5]
#   |+-------------dna_[dna_filter_options_md5]/plink_[dna_filder_options_md5]
#   |+-------------rna_[rna_filter_options_md5]
#   |+-------------peer_[step3_md5]/
#   |+-------------panama_[step3_md5]/
#   |+-------------none_[step3_md5]/
#	{1,2,...}
#       1.hd5



# HASH
step1_hash!=echo $(minGQ) $(minRD)  $(vcf_filter_cmd) |md5sum|cut -f1 -d' ' 
step1a_hash!=echo $(step1_hash) $(mac) $(max_missing) $(vcfs) $(chromosomes) |md5sum|cut -f1 -d' ' 
step2_hash!=echo $(min_expr) $(min_perc_samples) $(expr_transform) $(hidden_k)|md5sum|cut -f1 -d' '


ifeq ($(corr_method),peer)
step3_hash!=echo $(step1a_hash) $(step2_hash) $(peer_iterations) $(limix_use_peer_covariates) $(hidden_k) $(expr_transform)|md5sum|cut -f1 -d' '
else
ifeq ($(corr_method),panama)
step3_hash!=echo $(step1a_hash) $(step2_hash)  $(hidden_k) $(snr_threshold) $(expr_transform)|md5sum|cut -f1 -d' '
else
step3_hash!=echo $(step1a_hash) $(step2_hash)|md5sum|cut -f1 -d' '
endif
endif

step1_dir:=$(name)/dna_$(step1_hash)
step1a_dir:=$(step1_dir)/plink_$(step1a_hash)
step2_dir:=$(name)/$(subfolder_name)rna_$(step2_hash)
step3_dir:=$(name)/$(subfolder_name)$(corr_method)_$(step3_hash)
report_dir=$(step3_dir)/$(corr_method)/$(eqtl_method)/report

# print the folders
$(info * )
$(info * Output will be placed in $(name)/)
$(info * DNA folder (step1_dir)=$(step1_dir))
$(info * DNA folder - merged vcfs=$(step1a_dir))
$(info * RNA folder (step2_dir)=$(step2_dir))
$(info * QTL folder (step3_dir)=$(step3_dir))
$(info * Report/plots folder =$(report_dir))
$(info * )
###############
# names of files
cov_hdf5=$(name)/$(notdir $(basename $(cov_matrix))).hdf5
cov_sorted_hdf5=$(name)/$(notdir $(basename $(cov_matrix))).sorted.hdf5

gtf_eqtl_tsv=$(subst .gtf,.gtf.eqtl.tsv,$(subst .gz,,$(gtf_file)))
expr_matrix_filename=$(notdir $(basename $(expr_matrix)))
matched_expr_matrix=$(step1a_dir)/$(expr_matrix_filename).matched.tsv
kpop_file=$(step1a_dir)/Kpop.hdf5
samples_hdf5=$(step1a_dir)/samples.hdf5

################################################################################
# Make stuff
phony_targets=
silent_targets= 

empty:=
space:=$(empty) $(empty)#
################################################################################
# AUXILIARY FUNCTIONS
################################################################################


# create the folders
$(foreach f,$(step1_dir) $(step1a_dir) $(step2_dir) $(step3_dir)/$(eqtl_method),$(shell if [ ! -e $f ]; then mkdir -p $f; fi))


################################################################################
# Default target
$(info ***************************************************************)
all: step0 step1 step2 step3 step4 plots
	@echo "All done!"

################################################################################
#
################################################################################
# Generic file extension rules

# 
%.vcf.gz.tbi: %.vcf.gz
	tabix -p vcf $< || ( rm -f $@ && exit 1)

%.vcf.tbi: %.vcf
	tabix -p vcf $<  || ( rm -f $@ && exit 1)

%.gtf: %.gtf.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@
# 
%.gtf.eqtl.tsv: %.gtf
	get_annotation.sh $<  $@.tmp && mv $@.tmp $@


$(cov_hdf5): $(cov_matrix)
	get_covariates.py $< $@.tmp && mv $@.tmp $@ 

%.tsv: %.tsv.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@
#################################################################################
#
# Step0,1 and 2 may be executed independently
phony_targets+=step0 

step0: $(cov_hdf5)
#	$(call p_info,"Step 0 complete")



TARGETS0+=$(cov_hdf5)

#################################################################################
# DNA

step1: step0 $(step1a_dir)/complete
# STEP1
step1_a: tbi_files
step1_b: fix_vcf_headers
step1_c: filter_vcfs
step1_d: $(kpop_file) $(matched_expr_matrix) $(step1a_dir)/data_consistent

$(matched_expr_matrix): $(dna_rna_mapfile) $(expr_matrix)
	pheno_preprocessing.py $^ $@.tmp && mv $@.tmp $@ 

# Fix headers if necessary
FIXEDHEADER_VCFS=$(foreach l,$(vcfs),$(name)/vcf/$(subst .vcf.gz,.fixedheader.vcf.gz,$(l)))


# required: .tbi for each vcf
TBI_FILES=$(subst .vcf.gz,.vcf.gz.tbi,$(FIXEDHEADER_VCFS))
tbi_files: $(TBI_FILES)

TARGETS1+=$(TBI_FILES)

fix_vcf_headers: $(FIXEDHEADER_VCFS) 


#bgzip
$(name)/vcf/%.fixedheader.vcf.gz: $(vcf_toplevel_dir)/%.vcf.gz
	mkdir -p $(@D) && fix_vcf_header.sh $< $@.tmp && mv $@.tmp $@

$(shell mkdir -p $(name)/vcf)

# Rules to process each chr
# chr=$(1) 
define make-rules-for-chr=

$(shell mkdir -p $(step1_dir)/$(1))
$(shell mkdir -p $(step1a_dir)/$(1))

$(step1a_dir)/$(1)/chr$(1)_merged.vcf.gz: $$(foreach l,$(vcfs),$(step1_dir)/$(1)/$$(subst .vcf.gz,.filter.vcf.gz,$$(l))) $$(foreach l,$(vcfs),$(step1_dir)/$(1)/$$(subst .vcf.gz,.filter.vcf.gz.tbi,$$(l)))
	$$(file > $$@.lst,$$(foreach l,$(vcfs),$(step1_dir)/$(1)/$$(subst .vcf.gz,.filter.vcf.gz,$$(l))))  \
	sed -i -E "s/^ //;s/ +/\n/g" $$@.lst && \
	bcftools merge -l $$@.lst --output-type z > $$@.tmp && \
	rm -f $$@.lst && \
	mv $$@.tmp $$@

# 
$(step1_dir)/$(1)/%.filter.vcf.gz: $(name)/vcf/%.fixedheader.vcf.gz
	mkdir -p $$(@D) && $(vcf_filter_cmd) -i $$<  -c $(1) -g $$(minGQ) -d $$(minRD) | bgzip -c > $$@.tmp  && mv $$@.tmp $$@


##select MAC >=5, allow max missing sites in 20 percent of samples
$(step1a_dir)/$(1)/chr$(1)_merged.filt.vcf.gz: $(step1a_dir)/$(1)/chr$(1)_merged.vcf.gz
	vcftools --gzvcf $$< --max-missing $$(max_missing) --mac $$(mac)  --temp $$(@D) --recode --recode-INFO-all --out $$@.tmp && bgzip -c $$@.tmp.recode.vcf > $$@.tmp && mv $$@.tmp  $$@

$(step1a_dir)/$(1)/chr$(1).genotype.tsv: $(step1a_dir)/$(1)/chr$(1)_merged.filt.vcf.gz
	vcftools --012 --gzvcf $$< --out $$@.tmp &&
	generate_genotype_file $$@.tmp.012.indv $$@.tmp.012 $$@.tmp.012.pos  $$@.tmp &&	\
	mv $$@.tmp $$@


$(step1a_dir)/$(1)/chr$(1)_merged.filt.FILTER.summary: $(step1a_dir)/$(1)/chr$(1)_merged.vcf.gz
	mkdir -p $$(@D) && \
	vcftools --gzvcf $$< --max-missing $$(max_missing)  --temp $$(@D) --FILTER-summary --out $$@.tmp1 &&  \
	vcftools --gzvcf $$< --mac $$(mac)  --temp $$(@D) --FILTER-summary --out $$@.tmp2 && \
	vcftools --gzvcf $$< --mac $$(mac)  --max-missing $$(max_missing)  --temp $$(@D) --FILTER-summary --out $$@.tmp3 && \
	head -n 1 $$@.tmp1.FILTER.summary   | cut -f 1,2> $$@.tmp && \
	tail -n 1 $$@.tmp1.FILTER.summary | sed "s/PASS/Missing/" | cut -f 1,2 >> $$@.tmp && \
	tail -n 1 $$@.tmp2.FILTER.summary | sed "s/PASS/Mac/" | cut -f 1,2 >> $$@.tmp && \
	tail -n 1 $$@.tmp3.FILTER.summary | sed "s/PASS/Mac\&Missing/"  | cut -f 1,2 >> $$@.tmp && \
	mv $$@.tmp $$@

$(step1a_dir)/$(1)/chr$(1)_merged.filt.vcf.gz.plink: $(step1a_dir)/$(1)/chr$(1)_merged.filt.vcf.gz 
	mkdir -p $$(@D) && vcftools --gzvcf $$< --plink --out $$@.tmp && mv $$@.tmp.ped $$@.ped &&  mv $$@.tmp.map $$@.map && touch $$@


$(step1a_dir)/$(1)/plink_chr$(1).done: $(step1a_dir)/$(1)/chr$(1)_merged.filt.vcf.gz.plink
	mkdir -p $$(@D) && plink --file $$< --make-bed --fam --recode --noweb --out $$(subst .done,,$$@) && touch $$@

##convert genotypes into hdf5 file using limix binaries
##echo 'convert plink files into hdf5 files using limix binaries'
$(step1a_dir)/$(1)/chr$(1).hdf5: $(step1a_dir)/$(1)/plink_chr$(1).done 
	python $(LIMIX_BINARY)/limix_converter --outfile=$$@.tmp --plink=$$(subst .done,,$$<) && \
	geno_preprocessing.py $$@.tmp && \
	mv $$@.tmp $$@

endef

# Generate the rules per chr
$(foreach chr,$(chromosomes),$(eval $(call make-rules-for-chr,$(chr))))

# 
# build_Kpop.py kop.hdf5.tmp samples.hdf5 ...chr1.hdf5 ...chr2.hdf5 ...chr3.hdf5
$(kpop_file): $(foreach chr,$(chromosomes),$(step1a_dir)/$(chr)/chr$(chr).hdf5)
	build_Kpop.py $(kpop_file).tmp $(samples_hdf5).tmp $^ && \
	mv $(samples_hdf5).tmp $(samples_hdf5) &&\
	mv $(kpop_file).tmp $(kpop_file) && \
	sleep 1 && touch $(samples_hdf5)

$(samples_hdf5): $(kpop_file)
	if [ -e $@ ] ; then touch $(samples_hdf5); fi

$(step1_dir)/filter1/%.filter1.done: $(foreach chr,$(chromosomes),$(step1_dir)/$(chr)/$(subst .vcf.gz,.filter.vcf.gz.tbi,%.vcf.gz))	
	mkdir -p $(@D) && touch $@

FILTERED_VCF_FILES=$(foreach l,$(vcfs),$(step1_dir)/filter1/$(subst .vcf.gz,.filter1.done,$(l)))
FILTERED_VCF_FILES2=$(foreach chr,$(chromosomes),$(step1a_dir)/$(chr)/chr$(chr).hdf5)
#$(info $(FILTERED_VCF_FILES))
filter_vcfs:  $(FILTERED_VCF_FILES)
filter1: filter_vcfs
filter2: $(FILTERED_VCF_FILES2)

# one job per chr
TARGETS2+=$(FILTERED_VCF_FILES)
TARGETS3+=$(FILTERED_VCF_FILES2)

STEP1_TARGETS=$(step1a_dir)/data_consistent $(samples_hdf5) $(matched_expr_matrix) filter2 filter1   $(foreach chr,$(chromosomes),$(step1a_dir)/$(chr)/chr$(chr).genotype.tsv)
TARGETS4+=$(STEP1_TARGETS)


$(step1a_dir)/data_consistent: $(dna_rna_mapfile) $(samples_hdf5)
#	check_consistency.py $(dna_rna_mapfile) $(kpop_file) $(expr_matrix) && touch $(step1_dir)/data_consistent
	check_consistency.py $(dna_rna_mapfile) $(samples_hdf5) && touch $(step1a_dir)/data_consistent


$(step1a_dir)/complete:  $(STEP1_TARGETS) vcf_stats
	$(call p_info,"Step 1 complete") touch $@

################################################################################
# RNA

# step 2 need the kpop file
TARGETS5+=step1 step2


step2: $(step2_dir)/complete


$(step2_dir)/$(expr_matrix_filename).limix.hdf5: $(matched_expr_matrix) $(gtf_eqtl_tsv)
	$(LIMIX_BINARY)/limix_converter --outfile=$@.tmp --csv=$< && \
	hdf_annotation.py $(gtf_eqtl_tsv) $@.tmp && \
	mv $@.tmp $@ 


$(step2_dir)/$(expr_matrix_filename).filtered.hdf5: $(step2_dir)/$(expr_matrix_filename).limix.hdf5  $(samples_hdf5) $(cov_hdf5)
	cp $(cov_hdf5) $(cov_sorted_hdf5).tmp && \
	filtering_pheno.py $< $(min_expr) $(min_perc_samples) $(expr_transform) $@.tmp && \
	sort_ids.py $@.tmp $(cov_sorted_hdf5).tmp $(samples_hdf5) &&\
	mv $(cov_sorted_hdf5).tmp $(cov_sorted_hdf5) && \
	mv $@.tmp $@ 

$(cov_sorted_hdf5): $(step2_dir)/$(expr_matrix_filename).filtered.hdf5
	if [ -e $@ ] ; then touch $@; fi

# $(step2_dir)/$(expr_matrix_filename).filtered.hdf5
$(step2_dir)/complete:  $(matched_expr_matrix) $(step2_dir)/$(expr_matrix_filename).filtered.clus.png
	$(call p_info,"Step 2 complete") touch $@


######################################################################
# step3
step3: $(step3_dir)/complete

TARGETS6+= $(step3_dir)/$(corr_method)/$(corr_method).hdf5
# kpop - ktot
$(step3_dir)/panama/panama.hdf5: $(kpop_file) $(step2_dir)/$(expr_matrix_filename).filtered.hdf5
	mkdir -p $(@D) && \
	runpanama.py  $(kpop_file) $(step2_dir)/$(expr_matrix_filename).filtered.hdf5 $(hidden_k) $(snr_threshold) $@.tmp &&\
	mv $@.tmp  $@

$(step3_dir)/peer/peer.hdf5: $(step2_dir)/$(expr_matrix_filename).filtered.hdf5 $(if $(subst y,,$(limix_use_peer_covariates)),$(cov_sorted_hdf5))
	mkdir -p $(@D) && \
	runpeer.py $<  $(hidden_k) $(peer_iterations)  $@.tmp $(if $(subst y,,$(limix_use_peer_covariates)),$(cov_sorted_hdf5)) && \
	mv $@.tmp  $@

$(step3_dir)/none/none.hdf5: $(kpop_file)
	mkdir -p $(@D) && \
	cp $< $@.tmp && \
	mv $@.tmp  $@

#$(step3_dir)/$(corr_method)/$(corr_method).hdf5
$(step3_dir)/complete: $(step1a_dir)/complete $(step2_dir)/complete   $(step3_dir)/$(corr_method)/$(corr_method).clus.png
	$(call p_info,"Step 3 complete") touch $@
################################################################################
ifeq ($(eqtl_method),limix)
step4: $(step1a_dir)/complete $(step2_dir)/complete $(step3_dir)/complete $(step3_dir)/$(eqtl_method)/step4.complete
# 
#


# foreach chr
#   foreach fold_j in 1...nfolds
#     cis_eqtl.py $(chr) $(fold_j) $(nfolds) $(outname) -> chr/$nfolds_fold_j.hdf5
All_CisQTL_JOBS=$(foreach j,$(shell seq $(n_folds)),$(foreach chr,$(chromosomes), $(step3_dir)/$(eqtl_method)/$(chr)/$(n_folds)_$(j).hdf5))

# $(1)=chr
define CisQTL_JOBS_chr=
$(foreach j,$(shell seq $(n_folds)), $(step3_dir)/$(eqtl_method)/$(1)/$(n_folds)_$(j).hdf5)
endef

#$(info $(All_CisQTL_JOBS))
TARGETS7+=$(All_CisQTL_JOBS)



# $(1) = chr
define make-cisqtl-rule-chr=
$(step3_dir)/$(eqtl_method)/$(1)/$(n_folds)_%.hdf5: $(step1a_dir)/$(1)/chr$(1).hdf5 $(step2_dir)/$(expr_matrix_filename).filtered.hdf5  $(kpop_file) $(step3_dir)/$(corr_method)/$(corr_method).hdf5 $(cov_sorted_hdf5)
	mkdir -p $$(@D) && eqtl_cis.py $(step1a_dir)/$(1)/chr$(1).hdf5   $(step2_dir)/$(expr_matrix_filename).filtered.hdf5  $(corr_method)  $(step3_dir)/$(corr_method)/$(corr_method).hdf5  $(kpop_file) $(cov_sorted_hdf5) $(limix_use_peer_covariates) $(cis_window) $(n_folds) $$* $$@.tmp && mv $$@.tmp $$@

# $(step3_dir)/$(1)/summary.hdf5
$(step3_dir)/$(eqtl_method)/$(1).hdf5: $(call CisQTL_JOBS_chr,$(1))  $(cov_sorted_hdf5) $(step2_dir)/$(expr_matrix_filename).filtered.hdf5 $(step3_dir)/$(corr_method)/$(corr_method).hdf5
	$$(file >$$@.lst.txt,$(call CisQTL_JOBS_chr,$(1))) \
	sed -i -E "s/^ //;s/ +/\n/g" $$@.lst.txt && \
	eqtl_summary.py $(step1a_dir)/$(1)/chr$(1).hdf5  $(step2_dir)/$(expr_matrix_filename).filtered.hdf5  $(corr_method) $(step3_dir)/$(corr_method)/$(corr_method).hdf5  $(kpop_file) $(cov_sorted_hdf5) $(cis_window)  $(n_folds) $$@.lst.txt  $$@.tmp && \
	rm -f $$@.lst.txt && \
	mv $$@.tmp $$@

endef

$(foreach chr,$(chromosomes),$(eval $(call make-cisqtl-rule-chr,$(chr))))

$(step3_dir)/$(eqtl_method)/summary.tsv: $(foreach chr,$(chromosomes),$(step3_dir)/$(eqtl_method)/$(chr).hdf5)
	get_results.py $(fdr_threshold) $@.tmp $^ && mv $@.tmp $@


TARGETS8+=$(foreach chr,$(chromosomes),$(step3_dir)/$(eqtl_method)/$(chr).hdf5)

else
#######################################################
# matrixEQTL


# 1 - chr
# TODO: generate a pos file
ifeq ($(corr_method),none)
define make-meqtl-rule-chr=
$(step3_dir)/$(eqtl_method)/$(1).tsv: $(step1a_dir)/$(1)/chr$(1).genotype.tsv $(step2_dir)/$(expr_matrix_filename).filtered.tsv $(cov_sorted_hdf5).tsv $(gtf_eqtl_tsv)
	mkdir -p $$(@D) && run_matrix_eqtl $$< $(step2_dir)/$(expr_matrix_filename).filtered.tsv  $(cov_sorted_hdf5).tsv $(gtf_eqtl_tsv) $(cis_window) $(fdr_threshold) $$@.tmp && rename ".tmp" "" $$@.tmp*
endef

else

define make-meqtl-rule-chr=
$(step3_dir)/$(eqtl_method)/$(1).tsv: $(step1a_dir)/$(1)/chr$(1).genotype.tsv $(step3_dir)/$(corr_method)/$(corr_method).tsv $(cov_sorted_hdf5).tsv $(gtf_eqtl_tsv)
	mkdir -p $$(@D) && run_matrix_eqtl $$< $(step3_dir)/$(corr_method)/$(corr_method).tsv  $(cov_sorted_hdf5).tsv $(gtf_eqtl_tsv) $(cis_window) $(fdr_threshold) $$@.tmp && rename ".tmp" "" $$@.tmp*
endef
endif

$(foreach chr,$(chromosomes),$(eval $(call make-meqtl-rule-chr,$(chr))))

# merge all files into one
$(step3_dir)/$(eqtl_method)/summary.tsv: $(foreach chr,$(chromosomes),$(step3_dir)/$(eqtl_method)/$(chr).tsv)
	head -n 1 $< > $@.tmp && \
	tail -q -n +2 $^ >> $@.tmp && mv $@.tmp $@


TARGETS7+=$(foreach chr,$(chromosomes),$(step3_dir)/$(eqtl_method)/$(chr).tsv)
TARGETS8+=$(step3_dir)/$(eqtl_method)/summary.tsv


endif

step4: $(step1a_dir)/complete $(step2_dir)/complete $(step3_dir)/complete $(step3_dir)/$(eqtl_method)/step4.complete report

$(step3_dir)/$(eqtl_method)/step4.complete:  $(step3_dir)/$(eqtl_method)/summary.tsv
	$(call p_info,"Step 4 complete") touch $@

TARGETS9+=$(step1a_dir)/complete $(step2_dir)/complete $(step3_dir)/complete $(step3_dir)/step4.complete report

phony_targets+= setup setup_files

###################################################

###################################################
# Reports/plots
###################################################

# get a matrix from a specific .hdf5 file
# matrix/dataset kpop,ktot,phenotype
# row/col are switched?
$(cov_sorted_hdf5).tsv:  $(cov_sorted_hdf5)
	hdf52tsv $< "/covariates" "/row_header/sample_ID" "-"   $@.tmp y && mv $@.tmp $@

$(step2_dir)/$(expr_matrix_filename).filtered.tsv: $(step2_dir)/$(expr_matrix_filename).filtered.hdf5
	hdf52tsv $< "phenotype/Ytransformed" "phenotype/row_header/sample_ID" "/phenotype/col_header/phenotype_ID"   $@.tmp y && mv $@.tmp $@

$(step3_dir)/none/none.tsv: $(step3_dir)/none/none.hdf5
	hdf52tsv $< "Kpop" "/row_header/sample_ID" "/col_header/sample_ID"  $@.tmp  n && mv $@.tmp $@

$(step3_dir)/peer/peer.tsv: $(step3_dir)/peer/peer.hdf5
	hdf52tsv $< "/phenotype" "/row_header/sample_ID" "/col_header/phenotype_ID" $@.tmp y && mv $@.tmp $@

$(step3_dir)/panama/panama.tsv: $(step3_dir)/panama/panama.hdf5
	hdf52tsv $< "Ktot" "/row_header/sample_ID" "/col_header/sample_ID" $@.tmp y && mv $@.tmp $@


%.clus.png: %.tsv $(sample2class_file)
	generate_clustering  $< $(sample2class_file) $@.tmp && mv $@.tmp $@

%.pca.png %.pca_13.png: %.tsv $(sample2class_file)
	generate_pca  $< $(sample2class_file) $@ > $@.txt 


#########################################################################
report: plots vcf_stats

plots: $(report_dir)/plots

# Copy the plots and tsv file to the report folder
$(report_dir)/plots:  $(report_dir)/expr_filtered_clus.png $(report_dir)/expr_filtered_corrected_clus.png $(report_dir)/expr_filtered_pca.png $(report_dir)/expr_filtered_corrected_pca.png $(report_dir)/vcf_filtering.png

$(report_dir)/expr_filtered_clus.png:  $(step2_dir)/$(expr_matrix_filename).filtered.clus.png $(step2_dir)/$(expr_matrix_filename).filtered.tsv
	mkdir -p $(@D) && cp $^ $(@D) && cp $< $@

$(report_dir)/expr_filtered_pca.png:  $(step2_dir)/$(expr_matrix_filename).filtered.pca.png $(step2_dir)/$(expr_matrix_filename).filtered.pca_13.png $(step2_dir)/$(expr_matrix_filename).filtered.tsv
	mkdir -p $(@D) && cp $^ $(@D) && cp $< $@

$(report_dir)/expr_filtered_corrected_clus.png: $(step3_dir)/$(corr_method)/$(corr_method).clus.png $(step3_dir)/$(corr_method)/$(corr_method).tsv
	mkdir -p $(@D) && cp $^ $(@D) && cp $< $@

$(report_dir)/expr_filtered_corrected_pca.png: $(step3_dir)/$(corr_method)/$(corr_method).pca.png $(step3_dir)/$(corr_method)/$(corr_method).pca_13.png $(step3_dir)/$(corr_method)/$(corr_method).tsv
	mkdir -p $(@D) && cp $^ $(@D) && cp $< $@


###################################################
# filtering summary stats

########
# $(1) = chr  e.g, 1, 2, 3, ...
define make-vcf-stats-for-chr=

%.vcf.gz.chr$(1).summary: %.vcf.gz  %.vcf.gz.tbi
	bcftools stats -r "$(1)" $$< > $$@.tmp && mv $$@.tmp $$@

%.vcf.gz.chr$(1).snps: %.vcf.gz.chr$(1).summary
	echo -n "$(1) " | tr " " "\t" > $$@.tmp  && grep "records:" $$< | head -n1 | cut -f 4 >> $$@.tmp && mv $$@.tmp $$@
endef

$(foreach chr,$(chromosomes),$(eval $(call make-vcf-stats-for-chr,$(chr))))

%.vcf.gz.snps: $(foreach chr,$(chromosomes),%.vcf.gz.chr$(chr).snps)
	mkdir -p $(@D) && \
	echo "Chr $(notdir $*)" | sed -E "s/\s+/\t/g" > $@.tmp.col1 &&\
	cat $@.tmp.col1  $^ >$@ && rm -f $@.tmp $@.tmp.col1
# vcf file was already split by chr 
$(step1_dir)/%.vcf.gz.chr.snps: $(foreach chr,$(chromosomes),$(step1_dir)/$(chr)/%.vcf.gz.chr$(chr).snps)
	mkdir -p $(@D) && \
	echo "Chr $(notdir $*)" | sed -E "s/\s+/\t/g" > $@.tmp.col1 &&\
	cat $@.tmp.col1  $^ >$@ && rm -f $@.tmp $@.tmp.col1


VCF_STATS_0=$(foreach vcf,$(vcfs),$(name)/vcf/$(subst .vcf.gz,.fixedheader.vcf.gz,$(vcf)).snps)

$(report_dir)/vcf_snps_0.tsv: $(VCF_STATS_0)
	mkdir -p $(@D) && \
	$(file > $$@.tmp,Chr $(vcfs)) \
	sed -i "s/ /\t/g" $@.tmp && \
	cut -f 2- $@.tmp | mjoin -stdin | tail -n +2 | tr " " "\t">> $@.tmp  && mv $@.tmp $@

#
VCF_STATS_1=$(foreach vcf,$(vcfs),$(step1_dir)/$(subst .vcf.gz,.filter.vcf.gz,$(vcf)).chr.snps)
$(report_dir)/vcf_snps_1.tsv: $(VCF_STATS_1)
	mkdir -p $(@D) && \
	$(file > $$@.tmp,Chr $(vcfs)) \
	sed -i "s/ /\t/g" $@.tmp && \
	cut -f 2- $@.tmp | mjoin -stdin  | tail -n +2 |tr " " "\t">> $@.tmp  && mv $@.tmp $@

VCF_STATS_2=$(foreach c,$(chromosomes),$(step1a_dir)/$(c)/chr$(c)_merged.filt.FILTER.summary)	
$(report_dir)/vcf_snps_2.tsv: $(VCF_STATS_2)
	mkdir -p $(@D) && \
	echo Chr $(chromosomes) |tr " " "\t" > $@.tmp &&\
	mjoin $^ | tail -n +2 |tr " " "\t">> $@.tmp &&\
	mv  $@.tmp $@

TARGETS4+=$(VCF_STATS_1) $(VCF_STATS_2) $(VCF_STATS_3)

vcf_stats: $(report_dir)/vcf_snps_2.tsv $(report_dir)/vcf_snps_1.tsv $(report_dir)/vcf_snps_0.tsv 


$(report_dir)/vcf_filtering.png: $(report_dir)/vcf_snps_0.tsv $(report_dir)/vcf_snps_1.tsv $(report_dir)/vcf_snps_2.tsv  
	get_barplot.py $^ $@.tmp && mv $@.tmp $@


target_reports_vcfs1=$(VCF_STATS_0) $(VCF_STATS_1) $(VCF_STATS_2)

report_targets1:
	echo $(target_reports_vcfs1)
###################################################
targets0:
	$(info $(TARGETS0)) echo -n

targets1:
	$(info $(TARGETS1)) echo -n

targets2:
	$(info $(TARGETS2)) echo -n
targets3:
	$(info $(TARGETS3)) echo -n
targets4:
	$(info $(TARGETS4)) echo -n
targets5:
	$(info $(TARGETS5)) echo -n

targets6:
	$(info $(TARGETS6)) echo -n

targets7:
	$(info $(TARGETS7)) echo -n

targets8:
	$(info $(TARGETS8)) echo -n

targets9:
	$(info $(TARGETS9)) echo -n


###################################################
# FORCE the program to run even if files haven't changed
FORCE:


#PHONY: performance improvement. Tell MAKE that those targets don't generate any files. 
.PHONY:  $(phony_targets)
.SILENT: $(silent_targets)

###################################################
