#!/bin/sh
#; -*- mode: Makefile;-*-
#the next line restarts using\
exec make --warn-undefined-variables -Rf "$0"  ${1+"$@"} 
# =========================================================
# Copyright 2015
#
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
# =========================================================
###############################################################
# disable deletion of temporary files
.SECONDARY: 
.ONESHELL:

SHELL=bash
##################
# Setup some paths
# path to script
path=.
path?=$(shell if which eqtl_pipeline >/dev/null 2>/dev/null; then $(warning "eqtl_pipeline not in path"); else dirname `which eqtl_pipeline`; fi)

ifdef path
 PATH:=$(path):$(PATH)
endif

# Requires make 4.1 or above
VERSION_OK=$(shell if [ `make --version|head -n 1 | cut -f3 -d\ ` \< 4.1 ]; then echo 0; else echo 1; fi )
ifeq ($(VERSION_OK),0)
 $(error make version needs to be 4.1 or above)
endif

script_path:=$(shell dirname "`which eqtl_pipeline`"	)
################################################################################
# Auxiliary functions
################################################################################

# Information messages
define p_info=
$(info $(shell date "+%H:%M:%S %d/%m/%Y * ") $(1))
endef

# Error messages
define p_error=
$(info $(shell date "+%H:%M:%S %d/%m/%Y") * ERROR: $(1)) && $(error Fatal error)
endef

# complain if a file does not exist and exit
file_exists=$(if  $(realpath $(1)),,$(call p_error,$(1) not found))

#  check if a variable  $(1) is defined - return the variable name if it is defined or empty otherwise
is_defined=$(if $(subst undefined,,$(origin $(1))),$(1),)


################################################################################
# Variables
################################################################################

#Version and license info
pname=eqtlXXXXX
version=0.0.1
contact="Add contact"
license=This pipeline is distributed  under the terms of the GNU General Public License 3


################################################################################
# Default values
################################################################################
# max. memory (in MB)
def_max_mem=6000

def_max_threads=1

################################################################################
# go...

$(info *****************************************************)
$(info * $(pname) $(version))
$(info * $(contact))
$(info * $(license))
$(info *)
$(info * Initializing...)


###############################################
# Load configuration (mandatory)
# use a configuration file?
ifdef conf
 $(call file_exists,$(conf))
 $(info * Trying to load configuration file $(conf)...)
 include $(conf)
 $(info * Configuration loaded.)
else
 $(call p_error,Configuration file missing)
endif

###############################################
# Load some definitions
# include $(script_path)/../aux/mk/irap_defs.mk

###############################################################
# Check and validate the parameters values

$(info * )
$(info * Required Parameters:)

#***********************
# Name of the experiment
ifndef name
 $(call p_error, missing argument name!)
else
 $(info *	name=$(name))
endif

# cov_matrix?
# 

# expr_matrix (TSV File)
ifndef expr_matrix
 $(call p_error, missing argument expr_matrix!)
else
 $(info *	expr_matrix=$(expr_matrix))
endif
$(call file_exists,$(expr_matrix))

# two columns
# 1st column: DNA
# 2st column: RNA
ifndef dna_rna_mapfile
 $(call p_error, missing argument dna_rna_mapfile)
else
 $(info *	name=$(dna_rna_mapfile))
endif
$(call file_exists,$(dna_rna_mapfile))

#./scripts/eqtl_pipeline  dna_rna_mapfile=/dev/null conf=t.conf name=aaaa expr_matrix=t.conf vcfs=t.conf

#************************
# ?
ifndef vcfs
 $(call p_error,missing argument vcfs)
endif
$(info *	vcfs=$(vcfs))
#$(call file_exists,$(vcfs))
$(foreach l,$(vcfs),$(call file_exists,$(l)))

# TODO
cov_matrix=

# eqtl_pipeline vcfs=`ls mydir/*.vcf.gz`

#********* 
# GTF file?
ifndef gtf_file
 $(error gtf_file not defined)
endif
$(info *       gtf_file  = $(gtf_file))
$(call file_exists,$(gtf_file))

# vcfs??

chromosomes=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y MT

# 2 remove
LIMIX_BINARY=/panfs/nobackup/production/sds-pawg/ccalabre/germlinevcf/limix_pmbio/build/release.linux2/interfaces/python/bin/

peer_iterations=100



#####################
# Other Optional parameters
#####################
$(info * )
$(info * Optional Parameters:)


#
def_minGQ=50
def_minRD=20
def_rm_filter_all=true
def_vcf_filter=
# vcf_filter="TP > 0.95 ....."

def_max_missing=
def_mac=

# TODO
# use the default values if necessary
#$(for v,minGQ,minRD,rm_filter_all, )

#********
# Threads
#********
ifndef max_threads
 max_threads=$(def_max_threads)
endif
$(info *	max_threads=$(max_threads))


##############################
# expression correction method
SUPPORTED_CORR_METHODS=peer panama
ifndef corr_method
corr_method=none
endif

#corr_method expr_corr_method?
ifeq (,$(filter $(corr_method),$(SUPPORTED_CORR_METHODS) none))
$(error corr_method value $(corr_method) not supported)
endif

ifeq ($(corr_method),peer) 
$(info peer!!!)
else 
$(info *	corr_method=$(corr_method))
endif

#
# mem in MB
ifndef max_mem
max_mem=$(def_max_mem)
endif
# max memory in GB
max_mem_gb:=$(shell expr $(max_mem) \/ 1000)

# set memory (in bytes) to 65% of the max. memory available
#ifndef SAMTOOLS_SORT_MEM
# SAMTOOLS_SORT_MEM:=`expr $(max_mem) \* 1000000 \* 65 \/ 100`
#endif


# samtools 1.x
ifndef SAMTOOLS_SORT_MEM
 SAMTOOLS_SORT_MEM:=$(shell bash -c "expr $(max_mem_gb) \* 75 \/ 100")G
endif


#
# ${name}
#   |+-------------dna_[dna_filter_options_md5]
#   |+-------------rna_[rna_filter_options_md5]
#   |+-------------peer_[step3_md5]/
#   |+-------------panama_[step3_md5]/
#   |+-------------none_[step3_md5]/
#	{1,2,...}
#       1.hd5


# HASH
step1_hash=`echo $(minGQ) $(minRD) $(rm_filter_all) $(vcf_filter)|md5sum|cut -f1 -d\ `
step2_hash=`echo $(min_expr) $(min_perc_samples) $(expr_transform) $(hidden_k)|md5sum|cut -f1 -d\ `
# TODO
ifeq ($(corr_method),peer)
#peer
step3_hash=`echo $(step1_hash) $(step2_hash) $(peer_iterations) $(hidden_k) $(expr_transform)|md5sum|cut -f1 -d\ `
else
# panama
ifeq ($(corr_method),peer)
step3_hash=`echo $(step1_hash) $(step2_hash)  $(hidden_k) $(expr_transform)|md5sum|cut -f1 -d\ `
else
step3_hash=`echo $(step1_hash) $(step2_hash)|md5sum|cut -f1 -d\ `
fi
fi

step1_dir=$(name)/dna_$(step1_hash)
step2_dir=$(name)/rna_$(step2_hash)
step3_dir=$(name)/$(corr_method)_$(step3_hash)

$(info step1_dir=$(step1_dir))


################################################################################
# Make stuff
phony_targets=
silent_targets= 

empty:=
space:=$(empty) $(empty)#
################################################################################
# AUXILIARY FUNCTIONS
################################################################################

################################################################################
# TODO: STAGE0
SETUP_DATA_FILES=
STAGE3_OUT_FILES=
STAGE2_OUT_FILES=
STAGE4_OUT_FILES=
STAGE5_OUT_FILES=


#STAGE1_OUT_FILES=$(foreach p,$(se),$(call lib2filt_folder,$(p))$(p).f.fastq) $(foreach p,$(pe),$(call lib2filt_folder,$(p))$(p)_1.f.fastq)

################################################################################
# Default target
all: setup quality_filtering_and_report mapping quantification DE GSE


################################################################################
#
################################################################################
# Generic file extension rules

# to fix
%.vcf.gz.tbi: %.vcf.gz
	tabix -p $<

%.vcf.tbi: %.vcf
	tabix -p $<  

# TODO
%.gtf.eqtl.csv: %.gtf
	grep CDS $< | cut -f 1,2,3,4,5  > $@.tmp && mv $@.tmp $@








# uncompress rules
%.fa: %.fa.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@

%.fasta: %.fasta.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@

%.gtf: %.gtf.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@




#################################################################################
# DNA

step1: step1_a step1_b step1_d
# STEP1
step1_a: tbi_files
step1_b: fix_vcf_headers
step1_c: filter_vcfs
step1_d: $(step1_dir)/Kpop.hf5 $(step1_dir)/data_consistent


# required: .tbi for each vcf
TBI_FILES=$(foreach l,$(vcfs),$(l).tbi))
tbi_files: $(TBI_FILES)


# fix spaces in header?
FIXEDHEADER_VCFS=$(foreach l,$(vcfs),$(subst .vcf.gz,.fixedheader.vcf.gz,$(l)))
fix_vcf_headers: $(FIXEDHEADER_VCFS) 
	echo $(FIXEDHEADER_VCFS)

%.fixedheader.vcf.gz: %.vcf.gz
	fix_vcf_header.sh $< $@.tmp && mv $@.tmp $@


# filter VCF
$(step1_dir)/1/%.filt.vcf.gz: %.vcf.gz
	filter_vcf.sh $<  1  $@.tmp $(minRD) $(minGQ) $(rm_filter_all) "$(vcf_filter)"


$(step1_dir)/1/chr1.merged.vcf.gz: $(foreach l,$(vcfs),$(step1_dir)/1/$(subst .vcf.gz,.filter.vcf.gz,$(l))) $(foreach l,$(vcfs),$(step1_dir)/1/$(subst .vcf.gz,.filter.vcf.gz.tbi,$(l)))
	$(file > $@.lst, $(foreach l,$(vcfs),$(step1_dir)/1/$(subst .vcf.gz,.filter.vcf.gz,$(l)))) && \
	bcftools merge -l $@.lst | bgzip -c > $@.tmp && \
	mv $@.tmp $@


##select MAC >=5, allow max missing sites in 20 percent of samples
$(step1_dir)/plink/1/chr1.merged.vcf.gz.plink: $(step1_dir)/1/chr1.merged.vcf.gz
	mkdir -p $(@D) &&
	vcftools --gzvcf $< --max-missing 0.8 --mac 5 --recode --recode-INFO-all --out /dev/stdout | \
        vcftools --vcf /dev/stdin --plink --out $@.plink.tmp && mv $@.tmp $@ 


$(step1_dir)/plink/1/plink_chr1.done: $(step1_dir)/plink/1/chr1.merged.vcf.gz.plink
        plink --file $< --make-bed --noweb --out $(subst .done,,$@) && touch $@


##convert genotypes into hdf5 file using limix binaries
##echo 'convert plink files into hdf5 files using limix binaries'
$(step1_dir)/plink/1/chr1.hf5: $(step1_dir)/plink/1/plink_chr1.done
	echo 'input missing genotypes and calculate genetic kinship per chr'$chromosome &&
        python $(LIMIX_BINARY)/limix_converter --outfile=$@.tmp --plink=$(subst .done,,$<) && \
        cd ${data_dir}chr${chromosome} && \
        geno_preprocessing.py $@.tmp &&
	mv $@.tmp $@


#build_Kpop.py outfile hf5files....
#build_Kpop.py kop.hf5.tmp ...chr1.hf5 ...chr2.hf5 ...chr3.hf5
$(step1_dir)/Kpop.hf5: $(foreach chr,$(chromosomes),$(step1_dir)/plink/$(chr)/chr$(chr).hf5)
	build_Kpop.py  $@.tmp $^ && \
	mv $@.tmp $@

$(step1_dir)/data_consistent: $(dna_rna_mapfile) $(step1_dir)/Kpop.hf5 $(expr_matrix)
	check_consistency $(dna_rna_mapfile) $(step1_dir)/Kpop.hf5 $(expr_matrix) && touch $(step1_dir)/data_consistent

################################################################################
# RNA

#
gtf_eqtl_csv=$(subst .gtf,.gtf.eqtl.csv,$(gtf_file))
expr_matrix_filename=$(baseme $(expr_matrix))

step2: $(stage2_dir)/$(expr_matrix_filename).filtered.hdf

step0: $(name)/$(expr_matrix_filename).matched.hdf

$(name)/$(expr_matrix).matched.csv: $(dna_rna_mapfile) $(expr_matrix)
	pheno_preprocessing.py $^ $@.tmp && mv $@.tmp $@

#        python ${python_scripts}pheno_preprocessing.py $data_dir $pheno_in $analysis_IDs $phenofileout  &&

min_expr=
min_perc_samples=
#possible values: gaussian log none
expr_transform=
hidden_k=

# TODO: hdf->hf5 ====> hdf5!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

%.hdf: %.csv
	$(LIMIX_BINARY)/limix_converter --outfile=$@.tmp --csv=$< && \
	hdf_annotation.py $(gtf_eqtl_csv) $@.tmp && \
	mv $@.tmp $@	


$(stage2_dir)/%.filtered.hdf: $(name)/%.hdf
	cp $< $@.tmp && \
	filtering_pheno.py $@.tmp $(min_expr) $(min_perc_samples) filtered $(expr_transform) && \
	mv $@.tmp $@


# echo 'filtering pheno data based on gene expression. Use gauss or log to normalise.'
: 



######################################################################
# step3
step3: $(step1_dir)/data_consistent



# kpop - ktot
$(step3_dir)/panama/panama.hf5: $(step1_dir)/Kpop.hf5 $(step2_dir)/$(expr_matrix_filename).filtered.hdf
	mkdir -p $(@D) && \
	cp $(step1_dir)/Kpop.hf5 $@.tmp && \
	runpanama.py  $@.tmp $(stage2_dir)/$(expr_matrix_filename).filtered.hdf $(hidden_k) $(expr_transform) &&\
	mv $@.tmp  $@

$(step3_dir)/peer/peer.hf5: $(step2_dir)/$(expr_matrix_filename).filtered.hdf
	mkdir -p $(@D) && \
	cp $< $@.tmp && \
        runpeer.py $@.tmp $(expr_transform) $(hidden_k) $(peer_iterations) $@.tmp && \
	mv $@.tmp  $@

$(step3_dir)/none/none.hf5: $(step1_dir)/Kpop.hf5
	mkdir -p $(@D) && \
	cp $< $@.tmp && \
	mv $@.tmp  $@

################################################################################
step4:

$(stage1_dir)/complete:
$(stage2_dir)/complete:
# 
#
n_folds=1000

#: $(stage1_dir)/complete $(stage2_dir)/complete $(stage2_dir)/$(expr_matrix_filename).filtered.hdf $(step3_dir)/$(corr_method)/$(corr_method).hf5 $(step1_dir)/Kpop.hf5 
#	cis_eqtl_run.py $(chr) $(step1_dir) $(stage2_dir)/$(expr_matrix_filename).filtered.hdf  $(corr_method) $(step3_dir)/$(corr_method)/$(corr_method).hf5 $(step1_dir)/Kpop.hf5 $(expr_transform) $(n_folds)
# 
#

# foreach chr
#   foreach fold_j in 1...nfolds
#     cis_eqtl.py $(chr) $(fold_j) $(nfolds) $(outname) -> chr/$nfolds_fold_j.hdf5


#cis_eqtl_summary2.py $(path2eqtl)/$chr/ $(nfolds)  outfile

#get_final_res.py $chromosome &&



################################################################################
# stage 0 - setup/initialization
setup: setup_dirs setup_files

phony_targets+= setup setup_files

################################################################################
# Setup initial files
# file with the length of the features (gene, isoform, exon)
SETUP_DATA_FILES+= $(name)/data/$(reference_basename).gene_class.txt $(index_files) $(gtf_file_abspath).checked  $(gtf_file_abspath).exon_id.gtf $(juncs_file_abspath) $(name)/data/$(reference_basename).chr_sizes.txt  $(annot_tsv) $(name)/data/$(reference_basename).introns.bed 


# No need to include these files since they are generated by some rule
# $(name)/data/introns.bed -> $(name)/data/genes.bed $(name)/data/exons.bed 
# $(gff3_file_abspath).csv -> $(gff3_file_abspath) 

setup_files: $(SETUP_DATA_FILES)

print_stage0_files: setup_dirs
	echo $(SETUP_DATA_FILES)


################################################################################
# get paths
print_step3_dir:
	echo $(step3_dir)

################################################################################
# Setup directory structure
phony_targets+= setup_dirs

setup_dirs: $(tmp_dir) $(name)/report/riq/ $(if $(mapper),$(name)/$(mapper)/) $(name)/data/  $(if $(quant_method),$(name)/$(mapper)/$(quant_method)/)  $(if $(de_method),$(name)/$(mapper)/$(quant_method)/$(de_method)/)
	$(call p_info,[DONE] Directory structure created)

$(tmp_dir):
	mkdir -p $@

# really required?
#$(data_dir)/data:
#	mkdir -p $@


###################################################
# FORCE the program to run even if files haven't changed
FORCE:


#PHONY: performance improvement. Tell MAKE that those targets don't generate any files. 
.PHONY:  $(phony_targets)
.SILENT: $(silent_targets)

###################################################
